1.retain：始终采取浅复制
<!----> 可变和不可变之间转化的方法1：
copy（结果都是不可变）：对于不可变对象copy采用的是浅复制（仍是不可变对象），引用计数器加1（其实这是编译器进行了优化，既然原来的对象不可变，复制之后的对象也不可变那么就没有必要再重新创建一个对象了）；对于可变对象copy采用的是深复制，引用计数器不变（原来的对象是可变，现在要产生一个不可变的当然得重新产生一个对象）；
mutablecopy（结果都是可变）：无论是可变对象还是不可变对象采取的都是深复制，引用计数器不变（如果从一个不可变对象产生一个可变对象自然不用说两个对象绝对不一样肯定是深复制；如果从一个可变对象产生出另一个可变对象，那么当其中一个对象改变自然不希望另一个对象改变，当然也是深复制）
<!----> 可变和不可变之间转化的方法2：
    NSMutableArray/NSArray *mutableArray = [NSMutableArray/NSArray arrayWithArray:array];
    NSMutableDictionary/NSDictionary * mDict = [NSMutableDictionary/NSDictionary  dictionaryWithDictionary:dict];
2.注：
<!--可变对象：当值发生了改变，那么地址也随之发生改变；-->

不可变对象：当值发生了改变，内容首地址不发生变化；

引用计数器：用于计算一个对象有几个指针在引用（有几个指针变量指向同一个内存地址）；

3.文件存储数据：路径是根本。
4.数据库存储：sqlite ： ‘
  打开数据库，利用sqlite3_open()打开数据库会指定一个数据库文件保存路径，如果文件存在则直接打开，否则创建并打开。打开数据库会得到一个sqlite3类型的对象，后面需要借助这个对象进行其他操作。
执行SQL语句，执行SQL语句又包括有返回值的语句和无返回值语句：
对于无返回值的语句（如增加、删除、修改等）直接通过sqlite3_exec()函数执行；
对于有返回值的语句则首先通过sqlite3_prepare_v2()进行sql语句评估（语法检测），然后通过sqlite3_step()依次取出查询结果的每一行数据，对于每行数据都可以通过对应的sqlite3_column_类型()方法获得对应列的数据，如此反复循环直到遍历完成。当然，最后需要释放句柄。

<!----> 1个消息：1看返回值，2看参数。1返回值连接着 = 左边的类型和名称，参数一端连着属性，另一端连着要开发者要设置的内容。





